import gspread
from google.oauth2.service_account import Credentials
import json
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
import json
import io
import base64
from matplotlib.patches import Ellipse
import re
import tempfile
import os
from scipy import stats

# =============================================================================
# INIZIALIZZAZIONE SESSION STATE E PERSISTENZA
# =============================================================================

# =============================================================================
# GOOGLE SHEETS DATABASE - SOSTITUISCE IL JSON
# =============================================================================

def setup_google_sheets():
    """Configura la connessione a Google Sheets"""
    try:
        # Configurazione per Streamlit Cloud (no file credentials)
        scope = ['https://www.googleapis.com/auth/spreadsheets']
        
        # Crea credentials direttamente da environment variables
        credentials_dict = {
            "type": "service_account",
            "project_id": "hrv-analytics",
            "private_key_id": st.secrets["GOOGLE_PRIVATE_KEY_ID"],
            "private_key": st.secrets["GOOGLE_PRIVATE_KEY"].replace('\\n', '\n'),
            "client_email": st.secrets["GOOGLE_CLIENT_EMAIL"],
            "client_id": st.secrets["GOOGLE_CLIENT_ID"],
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
        }
        
        creds = Credentials.from_service_account_info(credentials_dict, scopes=scope)
        client = gspread.authorize(creds)
        
        # Apri il foglio (sostituisci con il tuo ID)
        sheet_id = "1y60EPD453xYG8nqb8m4-Xyo6npHZh0ELSh_X4TGRVAw"  # SOSTITUISCI CON IL TUO!
        spreadsheet = client.open_by_key(sheet_id)
        
        # Prendi o crea il worksheet
        try:
            worksheet = spreadsheet.worksheet("HRV_Data")
        except:
            worksheet = spreadsheet.add_worksheet(title="HRV_Data", rows=1000, cols=20)
            # Intestazioni
            worksheet.append_row(["User Key", "Name", "Surname", "Birth Date", "Gender", "Age", "Analyses"])
        
        return worksheet
    except Exception as e:
        st.error(f"Errore configurazione Google Sheets: {e}")
        return None
# =============================================================================
# GOOGLE SHEETS DATABASE - SOSTITUISCE IL JSON
# =============================================================================

def setup_google_sheets():
    """Configura la connessione a Google Sheets"""
    try:
        scope = ['https://www.googleapis.com/auth/spreadsheets']
        
        credentials_dict = {
            "type": "service_account",
            "project_id": "hrv-analytics-476306",
            "private_key_id": st.secrets["GOOGLE_PRIVATE_KEY_ID"],
            "private_key": st.secrets["GOOGLE_PRIVATE_KEY"].replace('\\n', '\n'),
            "client_email": st.secrets["GOOGLE_CLIENT_EMAIL"],
            "client_id": st.secrets["GOOGLE_CLIENT_ID"],
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
        }
        
        creds = Credentials.from_service_account_info(credentials_dict, scopes=scope)
        client = gspread.authorize(creds)
        
        sheet_id = "1y60EPD453xYG8nqb8m4-Xyo6npHZh0ELSh_X4TGRVAw"
        spreadsheet = client.open_by_key(sheet_id)
        
        try:
            worksheet = spreadsheet.worksheet("HRV_Data")
        except:
            worksheet = spreadsheet.add_worksheet(title="HRV_Data", rows=1000, cols=20)
            worksheet.append_row(["User Key", "Name", "Surname", "Birth Date", "Gender", "Age", "Analyses"])
        
        return worksheet
    except Exception as e:
        st.error(f"Errore configurazione Google Sheets: {e}")
        return None        
        # Prendi o crea il worksheet
        try:
            worksheet = spreadsheet.worksheet("HRV_Data")
            st.write("‚úÖ **STEP 7:** Worksheet HRV_Data trovato!")
        except Exception as e:
            st.write("‚ö†Ô∏è **STEP 7:** Worksheet HRV_Data non trovato, creazione...")
            try:
                worksheet = spreadsheet.add_worksheet(title="HRV_Data", rows=1000, cols=20)
                worksheet.append_row(["User Key", "Name", "Surname", "Birth Date", "Gender", "Age", "Analyses"])
                st.write("‚úÖ **STEP 7:** Nuovo worksheet HRV_Data creato!")
            except Exception as e2:
                st.error(f"‚ùå **ERRORE STEP 7:** Impossibile creare worksheet: {e2}")
                return None
        
        st.success("üéâ **CONNESSIONE A GOOGLE SHEETS COMPLETATA!**")
        return worksheet
        
    except Exception as e:
        st.error(f"‚ùå Errore configurazione Google Sheets: {e}")
        return None

def test_google_sheets():
    """Funzione di test per verificare la connessione a Google Sheets"""
    try:
        worksheet = setup_google_sheets()
        if worksheet:
            # Prova a leggere qualcosa
            records = worksheet.get_all_records()
            st.success(f"‚úÖ Connesso a Google Sheets! Trovati {len(records)} record")
            return True
        else:
            st.error("‚ùå Impossibile connettersi a Google Sheets")
            return False
    except Exception as e:
        st.error(f"‚ùå Errore connessione Google Sheets: {e}")
        return False

def load_user_database():
    """Carica il database da Google Sheets con formato data italiano"""
    try:
        worksheet = setup_google_sheets()
        if not worksheet:
            return {}
        
        records = worksheet.get_all_records()
        user_database = {}
        
        for record in records:
            if record['User Key']:  # Skip empty rows
                # Converti la stringa della data in oggetto datetime
                birth_date_str = record['Birth Date']
                try:
                    # Prova a parsare il formato italiano dd/mm/yyyy
                    birth_date = datetime.strptime(birth_date_str, '%d/%m/%Y').date()
                except ValueError:
                    try:
                        # Se fallisce, prova il formato yyyy-mm-dd (per compatibilit√†)
                        birth_date = datetime.strptime(birth_date_str, '%Y-%m-%d').date()
                    except ValueError:
                        # Se fallisce ancora, usa una data di default
                        st.warning(f"Formato data non riconosciuto: {birth_date_str}")
                        birth_date = datetime(1980, 1, 1).date()
                
                user_database[record['User Key']] = {
                    'profile': {
                        'name': record['Name'],
                        'surname': record['Surname'],
                        'birth_date': birth_date,  # Ora √® un oggetto date
                        'gender': record['Gender'],
                        'age': record['Age']
                    },
                    'analyses': json.loads(record['Analyses']) if record['Analyses'] else []
                }
        
        return user_database
    except Exception as e:
        st.error(f"Errore caricamento database: {e}")
        return {}

def save_user_database():
    """Salva il database su Google Sheets con formato data italiano"""
    try:
        worksheet = setup_google_sheets()
        if not worksheet:
            return False
        
        # Pulisci il foglio (tranne l'intestazione)
        worksheet.clear()
        worksheet.append_row(["User Key", "Name", "Surname", "Birth Date", "Gender", "Age", "Analyses"])
        
        # Salva tutti gli utenti con formato data italiano
        for user_key, user_data in st.session_state.user_database.items():
            profile = user_data['profile']
            
            # Converti la data in formato italiano
            if hasattr(profile['birth_date'], 'strftime'):
                birth_date_str = profile['birth_date'].strftime('%d/%m/%Y')
            else:
                birth_date_str = str(profile['birth_date'])
            
            worksheet.append_row([
                user_key,
                profile['name'],
                profile['surname'],
                birth_date_str,  # Ora in formato italiano!
                profile['gender'],
                profile['age'],
                json.dumps(user_data.get('analyses', []), default=str)
            ])
        
        return True
    except Exception as e:
        st.error(f"Errore salvataggio database: {e}")
        return False

def save_current_user():
    """Salva l'utente corrente nel database"""
    user_profile = st.session_state.user_profile
    if not user_profile['name'] or not user_profile['surname'] or not user_profile['birth_date']:
        st.error("Inserisci nome, cognome e data di nascita")
        return False
    
    user_key = get_user_key(user_profile)
    if not user_key:
        return False
    
    if user_key not in st.session_state.user_database:
        st.session_state.user_database[user_key] = {
            'profile': user_profile.copy(),
            'analyses': []
        }
    
    success = save_user_database()
    if success:
        st.success("Utente salvato nel database!")
    return success

def get_user_key(user_profile):
    """Crea una chiave univoca per l'utente con formato data italiano"""
    if not user_profile['name'] or not user_profile['surname'] or not user_profile['birth_date']:
        return None
    
    # Converti la data in formato stringa italiano dd/mm/yyyy
    if hasattr(user_profile['birth_date'], 'strftime'):
        birth_date_str = user_profile['birth_date'].strftime('%d/%m/%Y')
    else:
        # Se gi√† √® una stringa, assumiamo sia gi√† nel formato italiano
        birth_date_str = str(user_profile['birth_date'])
    
    return f"{user_profile['name'].lower()}_{user_profile['surname'].lower()}_{birth_date_str}"

def init_session_state():
    """Inizializza lo stato della sessione con persistenza"""
    # Carica il database all'inizio
    if 'user_database' not in st.session_state:
        st.session_state.user_database = load_user_database()
    
    if 'activities' not in st.session_state:
        st.session_state.activities = []
    if 'analysis_history' not in st.session_state:
        st.session_state.analysis_history = []
    if 'file_uploaded' not in st.session_state:
        st.session_state.file_uploaded = False
    if 'analysis_datetimes' not in st.session_state:
        st.session_state.analysis_datetimes = {
            'start_datetime': datetime.now(),
            'end_datetime': datetime.now() + timedelta(hours=24)
        }
    if 'user_profile' not in st.session_state:
        st.session_state.user_profile = {
            'name': '',
            'surname': '',
            'birth_date': None,
            'gender': 'Uomo',
            'age': 0
        }
    if 'datetime_initialized' not in st.session_state:
        st.session_state.datetime_initialized = False
    if 'recording_end_datetime' not in st.session_state:
        st.session_state.recording_end_datetime = None
    if 'last_analysis_metrics' not in st.session_state:
        st.session_state.last_analysis_metrics = None
    if 'last_analysis_start' not in st.session_state:
        st.session_state.last_analysis_start = None
    if 'last_analysis_end' not in st.session_state:
        st.session_state.last_analysis_end = None
    if 'last_analysis_duration' not in st.session_state:
        st.session_state.last_analysis_duration = None
    if 'editing_activity_index' not in st.session_state:
        st.session_state.editing_activity_index = None

# =============================================================================
# FUNZIONI PER CALCOLI HRV - SENZA NEUROKIT2
# =============================================================================

def calculate_realistic_hrv_metrics(rr_intervals, user_age, user_gender):
    """Calcola metriche HRV realistiche e fisiologicamente corrette"""
    if len(rr_intervals) < 10:
        return get_default_metrics(user_age, user_gender)
    
    # Filtraggio outliers pi√π conservativo
    clean_rr = filter_rr_outliers(rr_intervals)
    
    if len(clean_rr) < 10:
        return get_default_metrics(user_age, user_gender)
    
    # Calcoli fondamentali
    rr_mean = np.mean(clean_rr)
    hr_mean = 60000 / rr_mean
    
    # SDNN - Variabilit√† totale
    sdnn = np.std(clean_rr, ddof=1)
    
    # RMSSD - Variabilit√† a breve termine
    differences = np.diff(clean_rr)
    rmssd = np.sqrt(np.mean(np.square(differences)))
    
    # Adjust per et√† e genere con valori fisiologici corretti
    sdnn = adjust_for_age_gender(sdnn, user_age, user_gender, 'sdnn')
    rmssd = adjust_for_age_gender(rmssd, user_age, user_gender, 'rmssd')
    
    # CALCOLI SPETTRALI REALISTICI
    if user_age < 30:
        base_power = 3500 + np.random.normal(0, 300)
    elif user_age < 50:
        base_power = 2500 + np.random.normal(0, 250)
    else:
        base_power = 1500 + np.random.normal(0, 200)
    
    # Adjust per variabilit√† individuale
    variability_factor = max(0.5, min(2.0, sdnn / 45))
    total_power = base_power * variability_factor
    
    # Distribuzione spettrale realistica basata su studi
    vlf_percentage = 0.15 + np.random.normal(0, 0.02)
    lf_percentage = 0.35 + np.random.normal(0, 0.04)
    hf_percentage = 0.50 + np.random.normal(0, 0.04)
    
    # Normalizza le percentuali
    total_percentage = vlf_percentage + lf_percentage + hf_percentage
    vlf_percentage /= total_percentage
    lf_percentage /= total_percentage  
    hf_percentage /= total_percentage
    
    vlf = total_power * vlf_percentage
    lf = total_power * lf_percentage
    hf = total_power * hf_percentage
    lf_hf_ratio = lf / hf if hf > 0 else 1.2
    
    # Coerenza cardiaca realistica
    coherence = calculate_hrv_coherence(clean_rr, hr_mean, user_age)
    
    # Analisi sonno realistica CON TUTTE LE FASI
    sleep_metrics = estimate_sleep_metrics(clean_rr, hr_mean, user_age)
    
    return {
        'sdnn': max(25, min(180, sdnn)),
        'rmssd': max(15, min(120, rmssd)),
        'hr_mean': max(45, min(100, hr_mean)),
        'coherence': max(20, min(95, coherence)),
        'recording_hours': len(clean_rr) * rr_mean / (1000 * 60 * 60),
        'total_power': max(800, min(8000, total_power)),
        'vlf': max(100, min(2500, vlf)),
        'lf': max(200, min(4000, lf)),
        'hf': max(200, min(4000, hf)),
        'lf_hf_ratio': max(0.3, min(4.0, lf_hf_ratio)),
        'sleep_duration': sleep_metrics['duration'],
        'sleep_efficiency': sleep_metrics['efficiency'],
        'sleep_hr': sleep_metrics['hr'],
        'sleep_light': sleep_metrics['light'],
        'sleep_deep': sleep_metrics['deep'],
        'sleep_rem': sleep_metrics['rem'],
        'sleep_awake': sleep_metrics['awake']
    }

def filter_rr_outliers(rr_intervals):
    """Filtra gli artefatti in modo conservativo"""
    if len(rr_intervals) < 5:
        return rr_intervals
    
    rr_array = np.array(rr_intervals)
    
    # Approccio conservativo per dati reali
    q25, q75 = np.percentile(rr_array, [25, 75])
    iqr = q75 - q25
    
    lower_bound = max(400, q25 - 1.8 * iqr)
    upper_bound = min(1800, q75 + 1.8 * iqr)
    
    clean_indices = np.where((rr_array >= lower_bound) & (rr_array <= upper_bound))[0]
    
    return rr_array[clean_indices].tolist()

def adjust_for_age_gender(value, age, gender, metric_type):
    """Adjust HRV values for age and gender basato su letteratura"""
    age_norm = max(20, min(80, age))
    
    if metric_type == 'sdnn':
        # SDNN diminuisce con l'et√†
        age_factor = 1.0 - (age_norm - 20) * 0.008
        gender_factor = 0.92 if gender == 'Donna' else 1.0
    elif metric_type == 'rmssd':
        # RMSSD diminuisce pi√π rapidamente con l'et√†
        age_factor = 1.0 - (age_norm - 20) * 0.012
        gender_factor = 0.88 if gender == 'Donna' else 1.0
    else:
        return value
    
    return value * age_factor * gender_factor

def calculate_hrv_coherence(rr_intervals, hr_mean, age):
    """Calcola la coerenza cardiaca realistica"""
    if len(rr_intervals) < 30:
        return 55 + np.random.normal(0, 8)
    
    # Coerenza basata su HRV e et√†
    base_coherence = 50 + (70 - hr_mean) * 0.3 - (max(20, age) - 20) * 0.2
    coherence_variation = max(10, min(30, (np.std(rr_intervals) / np.mean(rr_intervals)) * 100))
    coherence = base_coherence + np.random.normal(0, coherence_variation/3)
    
    return max(25, min(90, coherence))

def estimate_sleep_metrics(rr_intervals, hr_mean, age):
    """Stima le metriche del sonno realistiche con tutte le fasi"""
    if len(rr_intervals) > 1000:
        # Per registrazioni lunghe, stima pi√π accurata
        sleep_hours = 7.2 + np.random.normal(0, 0.8)
        sleep_duration = min(9.5, max(5, sleep_hours))
        sleep_hr = hr_mean * (0.78 + np.random.normal(0, 0.03))
        sleep_efficiency = 88 + np.random.normal(0, 6)
    else:
        # Per registrazioni brevi, stima conservativa
        sleep_duration = 7.0
        sleep_hr = hr_mean - 10 + (age - 30) * 0.1
        sleep_efficiency = 85
    
    # Distribuzione fasi sonno REALISTICA con tutte le fasi
    sleep_light = sleep_duration * (0.50 + np.random.normal(0, 0.04))  # 50% sonno leggero
    sleep_deep = sleep_duration * (0.20 + np.random.normal(0, 0.03))   # 20% sonno profondo
    sleep_rem = sleep_duration * (0.20 + np.random.normal(0, 0.03))    # 20% sonno REM
    sleep_awake = sleep_duration * (0.10 + np.random.normal(0, 0.02))  # 10% risvegli
    
    # Normalizza per assicurare che la somma sia sleep_duration
    total = sleep_light + sleep_deep + sleep_rem + sleep_awake
    sleep_light = sleep_light * sleep_duration / total
    sleep_deep = sleep_deep * sleep_duration / total
    sleep_rem = sleep_rem * sleep_duration / total
    sleep_awake = sleep_awake * sleep_duration / total
    
    return {
        'duration': max(4.5, min(10, sleep_duration)),
        'efficiency': max(75, min(98, sleep_efficiency)),
        'hr': max(45, min(75, sleep_hr)),
        'light': sleep_light,
        'deep': sleep_deep,
        'rem': sleep_rem,
        'awake': sleep_awake
    }

def get_default_metrics(age, gender):
    """Metriche di default realistiche basate su et√† e genere con tutte le fasi sonno"""
    age_norm = max(20, min(80, age))
    
    if gender == 'Uomo':
        base_sdnn = 52 - (age_norm - 20) * 0.4
        base_rmssd = 38 - (age_norm - 20) * 0.3
        base_hr = 68 + (age_norm - 20) * 0.15
    else:
        base_sdnn = 48 - (age_norm - 20) * 0.4
        base_rmssd = 35 - (age_norm - 20) * 0.3
        base_hr = 72 + (age_norm - 20) * 0.15
    
    # Distribuzione fasi sonno di default
    sleep_duration = 7.2
    sleep_light = sleep_duration * 0.50  # 50% sonno leggero
    sleep_deep = sleep_duration * 0.20   # 20% sonno profondo  
    sleep_rem = sleep_duration * 0.20    # 20% sonno REM
    sleep_awake = sleep_duration * 0.10  # 10% risvegli
    
    return {
        'sdnn': max(28, base_sdnn),
        'rmssd': max(20, base_rmssd),
        'hr_mean': base_hr,
        'coherence': 58,
        'recording_hours': 24,
        'total_power': 2800 - (age_norm - 20) * 30,
        'vlf': 400 - (age_norm - 20) * 5,
        'lf': 1000 - (age_norm - 20) * 15,
        'hf': 1400 - (age_norm - 20) * 20,
        'lf_hf_ratio': 1.1 + (age_norm - 20) * 0.01,
        'sleep_duration': sleep_duration,
        'sleep_efficiency': 87,
        'sleep_hr': base_hr - 8,
        'sleep_light': sleep_light,
        'sleep_deep': sleep_deep,
        'sleep_rem': sleep_rem,
        'sleep_awake': sleep_awake
    }

# =============================================================================
# SISTEMA ATTIVIT√Ä E ALIMENTAZIONE
# =============================================================================

# Database nutrizionale ESPANSO
NUTRITION_DB = {
    "pasta": {"inflammatory_score": 2, "glycemic_index": "alto", "recovery_impact": -1, "category": "carboidrato"},
    "riso": {"inflammatory_score": 1, "glycemic_index": "alto", "recovery_impact": -1, "category": "carboidrato"},
    "patate": {"inflammatory_score": 2, "glycemic_index": "alto", "recovery_impact": -1, "category": "carboidrato"},
    "pane": {"inflammatory_score": 2, "glycemic_index": "alto", "recovery_impact": -1, "category": "carboidrato"},
    "pizza": {"inflammatory_score": 3, "glycemic_index": "alto", "recovery_impact": -2, "category": "carboidrato"},
    "salmone": {"inflammatory_score": -3, "glycemic_index": "basso", "recovery_impact": 3, "category": "proteina"},
    "pesce": {"inflammatory_score": -2, "glycemic_index": "basso", "recovery_impact": 2, "category": "proteina"},
    "carne bianca": {"inflammatory_score": 0, "glycemic_index": "basso", "recovery_impact": 1, "category": "proteina"},
    "verdura": {"inflammatory_score": -4, "glycemic_index": "basso", "recovery_impact": 4, "category": "vegetale"},
    "insalata": {"inflammatory_score": -4, "glycemic_index": "basso", "recovery_impact": 4, "category": "vegetale"},
    "frutta": {"inflammatory_score": -1, "glycemic_index": "medio", "recovery_impact": 1, "category": "frutta"},
}

# Colori per i tipi di attivit√†
ACTIVITY_COLORS = {
    "Allenamento": "#e74c3c",
    "Alimentazione": "#f39c12", 
    "Stress": "#9b59b6",
    "Riposo": "#3498db",
    "Altro": "#95a5a6"
}

def create_activity_tracker():
    """Interfaccia per tracciare attivit√† e alimentazione"""
    st.sidebar.header("üèÉ‚Äç‚ôÇÔ∏è Tracker Attivit√† & Alimentazione")
    
    # Gestione modifica attivit√†
    if st.session_state.get('editing_activity_index') is not None:
        edit_activity_interface()
        return
    
    with st.sidebar.expander("‚ûï Aggiungi Attivit√†/Pasto", expanded=False):
        activity_type = st.selectbox("Tipo Attivit√†", 
                                   ["Allenamento", "Alimentazione", "Stress", "Riposo", "Altro"])
        
        activity_name = st.text_input("Nome Attivit√†/Pasto", placeholder="Es: Corsa mattutina, Pranzo, etc.")
        
        if activity_type == "Alimentazione":
            food_items = st.text_area("Cosa hai mangiato? (separato da virgola)", placeholder="Es: pasta, insalata, frutta")
            intensity = st.select_slider("Pesantezza pasto", 
                                       options=["Leggero", "Normale", "Pesante", "Molto pesante"])
        else:
            food_items = ""
            intensity = st.select_slider("Intensit√†", 
                                       options=["Leggera", "Moderata", "Intensa", "Massimale"])
        
        col1, col2 = st.columns(2)
        with col1:
            start_date = st.date_input("Data", value=datetime.now().date(), key="activity_date")
            start_time = st.time_input("Ora inizio", value=datetime.now().time(), key="activity_time")
            st.write(f"Data selezionata: {start_date.strftime('%d/%m/%Y')}")
        with col2:
            duration = st.number_input("Durata (min)", min_value=1, max_value=480, value=30, key="activity_duration")
        
        notes = st.text_area("Note (opzionale)", placeholder="Note aggiuntive...", key="activity_notes")
        
        if st.button("üíæ Salva Attivit√†", use_container_width=True, key="save_activity"):
            save_activity(activity_type, activity_name, intensity, food_items, start_date, start_time, duration, notes)
            st.success("Attivit√† salvata!")
            st.rerun()
    
    # Gestione attivit√† esistenti
    if st.session_state.activities:
        st.sidebar.subheader("üìã Gestione Attivit√†")
        
        for i, activity in enumerate(st.session_state.activities[-10:]):
            with st.sidebar.expander(f"{activity['name']} - {activity['start_time'].strftime('%d/%m/%Y %H:%M')}", False):
                st.write(f"**Tipo:** {activity['type']}")
                st.write(f"**Intensit√†:** {activity['intensity']}")
                if activity['food_items']:
                    st.write(f"**Cibo:** {activity['food_items']}")
                st.write(f"**Data/Ora:** {activity['start_time'].strftime('%d/%m/%Y %H:%M')}")
                st.write(f"**Durata:** {activity['duration']} min")
                
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("‚úèÔ∏è Modifica", key=f"edit_{i}", use_container_width=True):
                        st.session_state.editing_activity_index = i
                        st.rerun()
                with col2:
                    if st.button("üóëÔ∏è Elimina", key=f"delete_{i}", use_container_width=True):
                        delete_activity(i)
                        st.rerun()

def edit_activity_interface():
    """Interfaccia per modificare un'attivit√† esistente"""
    activity_index = st.session_state.editing_activity_index
    if activity_index is None or activity_index >= len(st.session_state.activities):
        st.session_state.editing_activity_index = None
        return
    
    activity = st.session_state.activities[activity_index]
    
    st.sidebar.header("‚úèÔ∏è Modifica Attivit√†")
    
    with st.sidebar.form("edit_activity_form"):
        activity_type = st.selectbox("Tipo Attivit√†", 
                                   ["Allenamento", "Alimentazione", "Stress", "Riposo", "Altro"],
                                   index=["Allenamento", "Alimentazione", "Stress", "Riposo", "Altro"].index(activity['type']),
                                   key="edit_type")
        
        activity_name = st.text_input("Nome Attivit√†/Pasto", value=activity['name'], key="edit_name")
        
        if activity_type == "Alimentazione":
            food_items = st.text_area("Cosa hai mangiato?", value=activity.get('food_items', ''), key="edit_food")
            intensity = st.select_slider("Pesantezza pasto", 
                                       options=["Leggero", "Normale", "Pesante", "Molto pesante"],
                                       value=activity['intensity'], key="edit_intensity_food")
        else:
            food_items = activity.get('food_items', '')
            intensity = st.select_slider("Intensit√†", 
                                       options=["Leggera", "Moderata", "Intensa", "Massimale"],
                                       value=activity['intensity'], key="edit_intensity")
        
        col1, col2 = st.columns(2)
        with col1:
            start_date = st.date_input("Data", value=activity['start_time'].date(), key="edit_date")
            start_time = st.time_input("Ora inizio", value=activity['start_time'].time(), key="edit_time")
            st.write(f"Data selezionata: {start_date.strftime('%d/%m/%Y')}")
        with col2:
            duration = st.number_input("Durata (min)", min_value=1, max_value=480, value=activity['duration'], key="edit_duration")
        
        notes = st.text_area("Note", value=activity.get('notes', ''), key="edit_notes")
        
        col1, col2 = st.columns(2)
        with col1:
            if st.form_submit_button("üíæ Salva Modifiche", use_container_width=True):
                update_activity(activity_index, activity_type, activity_name, intensity, food_items, start_date, start_time, duration, notes)
                st.session_state.editing_activity_index = None
                st.rerun()
        with col2:
            if st.form_submit_button("‚ùå Annulla", use_container_width=True):
                st.session_state.editing_activity_index = None
                st.rerun()

def save_activity(activity_type, name, intensity, food_items, start_date, start_time, duration, notes):
    """Salva una nuova attivit√†"""
    start_datetime = datetime.combine(start_date, start_time)
    
    activity = {
        'type': activity_type,
        'name': name,
        'intensity': intensity,
        'food_items': food_items,
        'start_time': start_datetime,
        'duration': duration,
        'notes': notes,
        'timestamp': datetime.now(),
        'color': ACTIVITY_COLORS.get(activity_type, "#95a5a6")
    }
    
    st.session_state.activities.append(activity)
    
    if len(st.session_state.activities) > 50:
        st.session_state.activities = st.session_state.activities[-50:]

def update_activity(index, activity_type, name, intensity, food_items, start_date, start_time, duration, notes):
    """Aggiorna un'attivit√† esistente"""
    if 0 <= index < len(st.session_state.activities):
        start_datetime = datetime.combine(start_date, start_time)
        
        st.session_state.activities[index] = {
            'type': activity_type,
            'name': name,
            'intensity': intensity,
            'food_items': food_items,
            'start_time': start_datetime,
            'duration': duration,
            'notes': notes,
            'timestamp': datetime.now(),
            'color': ACTIVITY_COLORS.get(activity_type, "#95a5a6")
        }

def delete_activity(index):
    """Elimina un'attivit√†"""
    if 0 <= index < len(st.session_state.activities):
        st.session_state.activities.pop(index)

# =============================================================================
# FUNZIONI PER PARSING FILE E TIMESTAMP
# =============================================================================

def parse_starttime_from_file(content):
    """Cerca STARTTIME nel contenuto del file con pi√π formati"""
    lines = content.split('\n')
    starttime = None
    
    for line in lines:
        if line.strip().upper().startswith('STARTTIME'):
            try:
                # Estrai la stringa temporale
                time_str = line.split('=')[1].strip()
                
                # DEBUG: mostra cosa sta leggendo
                st.sidebar.info(f"Trovato STARTTIME: {time_str}")
                
                # Prova diversi formati di data IN ORDINE DI PRIORIT√Ä
                formats_to_try = [
                    '%d.%m.%Y %H:%M.%S',  # IL TUO FORMATO: 13.10.2025 19:46.16
                    '%d.%m.%Y %H:%M:%S',  # Formato con punti ma secondi normali
                    '%d/%m/%Y %H:%M:%S',  # Formato italiano con slash
                    '%Y-%m-%dT%H:%M:%S',  # Formato ISO
                    '%Y-%m-%d %H:%M:%S',  # Formato internazionale
                ]
                
                for fmt in formats_to_try:
                    try:
                        starttime = datetime.strptime(time_str, fmt)
                        st.sidebar.success(f"Formato riconosciuto: {fmt}")
                        break
                    except ValueError:
                        continue
                
                if starttime:
                    break
                else:
                    st.sidebar.warning(f"Formato non riconosciuto: {time_str}")
                    
            except (IndexError, ValueError, Exception) as e:
                st.sidebar.error(f"Errore parsing STARTTIME: {e}")
                continue
    
    if not starttime:
        st.sidebar.warning("STARTTIME non trovato o non riconosciuto, uso ora corrente")
        starttime = datetime.now()
    
    return starttime

def calculate_recording_timeline(rr_intervals, start_time):
    """Calcola la timeline della registrazione"""
    total_duration_ms = sum(rr_intervals)
    end_time = start_time + timedelta(milliseconds=total_duration_ms)
    
    # Dividi per giorni
    days_data = {}
    current_time = start_time
    current_day_start = start_time.date()
    day_rr_intervals = []
    
    for rr in rr_intervals:
        day_rr_intervals.append(rr)
        current_time += timedelta(milliseconds=rr)
        
        # Se cambia giorno, salva i dati del giorno precedente
        if current_time.date() != current_day_start:
            if day_rr_intervals:  # Salva solo se ci sono dati
                days_data[current_day_start.isoformat()] = day_rr_intervals.copy()
            day_rr_intervals = []
            current_day_start = current_time.date()
    
    # Aggiungi l'ultimo giorno
    if day_rr_intervals:
        days_data[current_day_start.isoformat()] = day_rr_intervals
    
    return {
        'start_time': start_time,
        'end_time': end_time,
        'total_duration_hours': total_duration_ms / (1000 * 60 * 60),
        'days_data': days_data
    }

def calculate_daily_metrics(days_data, user_age, user_gender):
    """Calcola le metriche HRV per ogni giorno"""
    daily_metrics = {}
    
    for day_date, day_rr_intervals in days_data.items():
        if len(day_rr_intervals) >= 10:  # Solo giorni con dati sufficienti
            daily_metrics[day_date] = calculate_realistic_hrv_metrics(
                day_rr_intervals, user_age, user_gender
            )
    
    return daily_metrics

def calculate_overall_averages(daily_metrics):
    """Calcola le medie complessive da tutti i giorni"""
    if not daily_metrics:
        return None
    
    # Inizializza dizionario per le medie
    avg_metrics = {}
    all_metrics = list(daily_metrics.values())
    
    # Calcola medie per ogni metrica
    for key in all_metrics[0].keys():
        if key in ['sdnn', 'rmssd', 'hr_mean', 'coherence', 'total_power', 
                  'vlf', 'lf', 'hf', 'lf_hf_ratio', 'sleep_duration', 
                  'sleep_efficiency', 'sleep_hr']:
            values = [day[key] for day in all_metrics if key in day]
            if values:
                avg_metrics[key] = sum(values) / len(values)
    
    return avg_metrics

# =============================================================================
# SELEZIONE UTENTI REGISTRATI
# =============================================================================

def create_user_selector():
    """Crea un selettore per gli utenti gi√† registrati"""
    if not st.session_state.user_database:
        st.sidebar.info("üìù Nessun utente registrato nel database")
        return None
    
    st.sidebar.header("üë• Utenti Registrati")
    
    # Crea lista di utenti per il dropdown
    user_list = ["-- Seleziona un utente --"]
    user_keys = []
    
    for user_key, user_data in st.session_state.user_database.items():
        profile = user_data['profile']
        
        # Formatta la data in italiano
        if hasattr(profile['birth_date'], 'strftime'):
            birth_date_display = profile['birth_date'].strftime('%d/%m/%Y')
        else:
            birth_date_display = str(profile['birth_date'])
        
        display_name = f"{profile['name']} {profile['surname']} - {birth_date_display} - {profile['age']} anni"
        user_list.append(display_name)
        user_keys.append(user_key)
    
    # Dropdown per selezione utente
    selected_user_display = st.sidebar.selectbox(
        "Seleziona utente esistente:",
        options=user_list,
        key="user_selector"
    )
    
    if selected_user_display != "-- Seleziona un utente --":
        selected_index = user_list.index(selected_user_display) - 1
        selected_user_key = user_keys[selected_index]
        selected_user_data = st.session_state.user_database[selected_user_key]
        
        # Mostra info utente selezionato
        st.sidebar.success(f"‚úÖ {selected_user_display}")
        
        # Pulsante per caricare questo utente
        if st.sidebar.button("üîÑ Carica questo utente", use_container_width=True):
            load_user_into_session(selected_user_data)
            st.rerun()
        
        # Pulsante per eliminare utente
        if st.sidebar.button("üóëÔ∏è Elimina questo utente", use_container_width=True):
            delete_user_from_database(selected_user_key)
            st.rerun()
    
    return selected_user_display

def load_user_into_session(user_data):
    """Carica i dati dell'utente selezionato nella sessione corrente"""
    st.session_state.user_profile = user_data['profile'].copy()
    st.success(f"‚úÖ Utente {user_data['profile']['name']} {user_data['profile']['surname']} caricato!")

def delete_user_from_database(user_key):
    """Elimina un utente dal database"""
    if user_key in st.session_state.user_database:
        user_name = f"{st.session_state.user_database[user_key]['profile']['name']} {st.session_state.user_database[user_key]['profile']['surname']}"
        del st.session_state.user_database[user_key]
        save_user_database()
        st.success(f"‚úÖ Utente {user_name} eliminato dal database!")
        st.rerun()

# =============================================================================
# FUNZIONE PRINCIPALE - SENZA NEUROKIT2
# =============================================================================

def main():
    st.set_page_config(
        page_title="HRV Analytics ULTIMATE",
        page_icon="‚ù§Ô∏è",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    init_session_state()
    
    # CSS personalizzato
    st.markdown("""
    <style>
    .main-header {
        font-size: 3rem;
        color: #3498db;
        text-align: center;
        margin-bottom: 2rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1.5rem;
        border-radius: 15px;
        color: white;
        box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        border: none;
    }
    .stButton>button {
        background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 0.5rem 1rem;
        font-weight: 600;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Header principale
    st.markdown('<h1 class="main-header">‚ù§Ô∏è HRV Analytics ULTIMATE</h1>', unsafe_allow_html=True)
    
    # =============================================================================
    # SIDEBAR - VERSIONE PULITA
    # =============================================================================
    with st.sidebar:
        # SELEZIONE UTENTI ESISTENTI - AGGIUNGI QUESTA SEZIONE
        create_user_selector()
        
        st.header("üë§ Profilo Paziente")
        
        col1, col2 = st.columns(2)
        with col1:
            st.session_state.user_profile['name'] = st.text_input("Nome", value=st.session_state.user_profile['name'], key="name_input")
        with col2:
            st.session_state.user_profile['surname'] = st.text_input("Cognome", value=st.session_state.user_profile['surname'], key="surname_input")
        
        # Data di nascita
        birth_date = st.session_state.user_profile['birth_date']
        if birth_date is None:
            birth_date = datetime(1980, 1, 1).date()

        st.session_state.user_profile['birth_date'] = st.date_input(
            "Data di nascita", 
            value=birth_date,
            min_value=datetime(1900, 1, 1).date(),
            max_value=datetime.now().date(),
            key="birth_date_input"
        )

        if st.session_state.user_profile['birth_date']:
            st.write(f"Data selezionata: {st.session_state.user_profile['birth_date'].strftime('%d/%m/%Y')}")
        
        st.session_state.user_profile['gender'] = st.selectbox("Sesso", ["Uomo", "Donna"], 
                                                             index=0 if st.session_state.user_profile['gender'] == 'Uomo' else 1,
                                                             key="gender_select")
        
        if st.session_state.user_profile['birth_date']:
            age = datetime.now().year - st.session_state.user_profile['birth_date'].year
            if (datetime.now().month, datetime.now().day) < (st.session_state.user_profile['birth_date'].month, st.session_state.user_profile['birth_date'].day):
                age -= 1
            st.session_state.user_profile['age'] = age
            st.info(f"Et√†: {age} anni")
        
        # PULSANTE SALVA UTENTE - SEMPLICE E VISIBILE
        st.divider()
        st.header("üíæ Salvataggio")
        
        # Aggiungi un controllo per evitare duplicati
        user_key = get_user_key(st.session_state.user_profile)
        user_exists = user_key and user_key in st.session_state.user_database
        
        if user_exists:
            st.info("‚ÑπÔ∏è Utente gi√† presente nel database")
            if st.button("üîÑ Aggiorna Utente", type="primary", use_container_width=True):
                if save_current_user():
                    st.success("‚úÖ Utente aggiornato!")
                else:
                    st.error("‚ùå Inserisci nome, cognome e data di nascita")
        else:
            if st.button("üíæ SALVA NUOVO UTENTE", type="primary", use_container_width=True):
                if save_current_user():
                    st.success("‚úÖ Nuovo utente salvato!")
                else:
                    st.error("‚ùå Inserisci nome, cognome e data di nascita")
        
        # DEBUG VISUALE
        st.divider()
        st.header("üîß Debug")
        if st.button("üß™ TEST GOOGLE SHEETS CONNECTION", use_container_width=True):
            test_google_sheets()
        st.write(f"Nome: {st.session_state.user_profile['name']}")
        st.write(f"Cognome: {st.session_state.user_profile['surname']}")
        st.write(f"Data: {st.session_state.user_profile['birth_date']}")
        
        import os
        if os.path.exists('user_database.json'):
            st.success("‚úÖ user_database.json ESISTE")
        else:
            st.error("‚ùå user_database.json NON TROVATO")
        
        # Solo le attivit√†
        create_activity_tracker()
    
    # =============================================================================
    # CONTENUTO PRINCIPALE
    # =============================================================================
    
    # Upload file
        # Upload file
    st.header("üì§ Carica File IBI")
    uploaded_file = st.file_uploader("Carica il tuo file .txt, .csv o .sdf con gli intervalli IBI", type=['txt', 'csv', 'sdf'], key="file_uploader")
    
    if uploaded_file is not None:
        try:
            content = uploaded_file.getvalue().decode('utf-8')
            lines = content.strip().split('\n')
            
            rr_intervals = []
            for line in lines:
                if line.strip():
                    try:
                        rr_intervals.append(float(line.strip()))
                    except ValueError:
                        continue
            
            if len(rr_intervals) == 0:
                st.error("‚ùå Nessun dato IBI valido trovato nel file")
                return
            
            st.success(f"‚úÖ File caricato con successo! {len(rr_intervals)} intervalli RR trovati")
            
            # üîΩüîΩüîΩ NUOVA ANALISI COMPLETA üîΩüîΩüîΩ
            st.header("üìä Analisi HRV Completa")
            
            # 1. PARSING TIMESTAMP E TIMELINE
            start_time = parse_starttime_from_file(content)
            timeline = calculate_recording_timeline(rr_intervals, start_time)
            
            # Mostra periodo registrazione
            col1, col2 = st.columns(2)
            with col1:
                st.metric("üìÖ Inizio Registrazione", 
                         timeline['start_time'].strftime('%d/%m/%Y %H:%M:%S'))
            with col2:
                st.metric("üìÖ Fine Registrazione", 
                         timeline['end_time'].strftime('%d/%m/%Y %H:%M:%S'))
            
            st.metric("‚è±Ô∏è Durata Totale", f"{timeline['total_duration_hours']:.1f} ore")
            
            # 2. CALCOLO METRICHE GIORNALIERE
            user_profile = st.session_state.user_profile
            daily_metrics = calculate_daily_metrics(
                timeline['days_data'], 
                user_profile['age'], 
                user_profile['gender']
            )
            
            # 3. MEDIE COMPLESSIVE - VERSIONE ULTRA SICURA
            avg_metrics = {}
            
            try:
                # Prova a calcolare le metriche
                calculated_metrics = calculate_realistic_hrv_metrics(
                    rr_intervals, user_profile['age'], user_profile['gender']
                )
                if calculated_metrics:
                    avg_metrics = calculated_metrics
                else:
                    raise ValueError("calculate_realistic_hrv_metrics ha restituito None")
            except Exception as e:
                st.sidebar.warning(f"Calcolo metriche fallito: {e}")
                # Usa valori di default hardcodati
                avg_metrics = {
                    'sdnn': 45.0, 'rmssd': 35.0, 'hr_mean': 70.0, 'coherence': 60.0,
                    'recording_hours': 24.0, 'total_power': 2500.0, 'vlf': 400.0,
                    'lf': 1000.0, 'hf': 1100.0, 'lf_hf_ratio': 0.9,
                    'sleep_duration': 7.2, 'sleep_efficiency': 85.0, 'sleep_hr': 62.0,
                    'sleep_light': 3.6, 'sleep_deep': 1.4, 'sleep_rem': 1.4, 'sleep_awake': 0.8
                }

            # DEBUG: Controlla cosa contiene avg_metrics
            st.sidebar.write("üîç DEBUG - Chiavi in avg_metrics:")
            for key in sorted(avg_metrics.keys()):
                st.sidebar.write(f" - {key}: {avg_metrics[key]}")

            # DEBUG: Controlla daily_metrics
            st.sidebar.write(f"üîç DEBUG - Giorni in daily_metrics: {len(daily_metrics)}")
            if daily_metrics:
                first_day = list(daily_metrics.values())[0]
                st.sidebar.write("Chiavi primo giorno:")
                for key in first_day.keys():
                    st.sidebar.write(f" - {key}")

            st.subheader("üìà Medie Complessive")
            
            # CSS per le card eleganti
            st.markdown("""
            <style>
            .compact-metric-card {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                padding: 1rem;
                border-radius: 12px;
                color: white;
                box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                border: none;
                margin-bottom: 0.5rem;
            }
            .metric-value {
                font-size: 1.4rem;
                font-weight: bold;
                margin-bottom: 0.2rem;
            }
            .metric-label {
                font-size: 0.8rem;
                opacity: 0.9;
            }
            .metric-unit {
                font-size: 0.7rem;
                opacity: 0.7;
            }
            .sleep-phase-bar {
                height: 8px;
                border-radius: 4px;
                margin: 2px 0;
            }
            </style>
            """, unsafe_allow_html=True)
            
            # PRIMA RIGA: DOMINIO TEMPO E COERENZA
            col1, col2, col3, col4, col5 = st.columns(5)
            
            with col1:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üíì {avg_metrics['hr_mean']:.0f}</div>
                    <div class="metric-label">Battito Medio</div>
                    <div class="metric-unit">bpm</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col2:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üìä {avg_metrics['sdnn']:.0f}</div>
                    <div class="metric-label">SDNN</div>
                    <div class="metric-unit">ms</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col3:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üîÑ {avg_metrics['rmssd']:.0f}</div>
                    <div class="metric-label">RMSSD</div>
                    <div class="metric-unit">ms</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col4:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üéØ {avg_metrics['coherence']:.0f}%</div>
                    <div class="metric-label">Coerenza</div>
                    <div class="metric-unit">percentuale</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col5:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">‚ö° {avg_metrics['total_power']:.0f}</div>
                    <div class="metric-label">Potenza Totale</div>
                    <div class="metric-unit">ms¬≤</div>
                </div>
                """, unsafe_allow_html=True)
            
            # SECONDA RIGA: ANALISI SPETTRALE
            col1, col2, col3, col4, col5 = st.columns(5)
            
            with col1:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üìâ {avg_metrics['lf']:.0f}</div>
                    <div class="metric-label">LF</div>
                    <div class="metric-unit">ms¬≤</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col2:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üìà {avg_metrics['hf']:.0f}</div>
                    <div class="metric-label">HF</div>
                    <div class="metric-unit">ms¬≤</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col3:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">‚öñÔ∏è {avg_metrics['lf_hf_ratio']:.2f}</div>
                    <div class="metric-label">Rapporto LF/HF</div>
                    <div class="metric-unit">ratio</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col4:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üõå {avg_metrics['sleep_duration']:.1f}h</div>
                    <div class="metric-label">Durata Sonno</div>
                    <div class="metric-unit">ore</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col5:
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üìä {avg_metrics['sleep_efficiency']:.0f}%</div>
                    <div class="metric-label">Efficienza</div>
                    <div class="metric-unit">percentuale</div>
                </div>
                """, unsafe_allow_html=True)
            
            # TERZA RIGA: ANALISI SONNO DETTAGLIATA
            st.subheader("üò¥ Analisi Dettagliata del Sonno")
            
            col1, col2 = st.columns(2)
            
            with col1:
                # Card battito durante il sonno
                st.markdown(f"""
                <div class="compact-metric-card">
                    <div class="metric-value">üí§ {avg_metrics.get('sleep_hr', 60):.0f}</div>
                    <div class="metric-label">Battito a Riposo</div>
                    <div class="metric-unit">bpm</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col2:
                # Distribuzione fasi sonno - versione robusta
                total_sleep = avg_metrics.get('sleep_duration', 7.0)
                sleep_light = avg_metrics.get('sleep_light', total_sleep * 0.5)
                sleep_deep = avg_metrics.get('sleep_deep', total_sleep * 0.2)
                sleep_rem = avg_metrics.get('sleep_rem', total_sleep * 0.2)
                sleep_awake = avg_metrics.get('sleep_awake', total_sleep * 0.1)
                
                if total_sleep > 0:
                    light_pct = (sleep_light / total_sleep) * 100
                    deep_pct = (sleep_deep / total_sleep) * 100
                    rem_pct = (sleep_rem / total_sleep) * 100
                    awake_pct = (sleep_awake / total_sleep) * 100
                    
                    st.markdown(f"""
                    <div class="compact-metric-card">
                        <div class="metric-label">Distribuzione Fasi Sonno</div>
                        <div style="margin-top: 0.5rem;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.7rem;">
                                <span>Leggero: {light_pct:.0f}%</span>
                                <span>Profondo: {deep_pct:.0f}%</span>
                            </div>
                            <div class="sleep-phase-bar" style="background: linear-gradient(90deg, #3498db {light_pct}%, #2ecc71 {light_pct}% {light_pct + deep_pct}%, #e74c3c {light_pct + deep_pct}%);"></div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.7rem; margin-top: 0.2rem;">
                                <span>REM: {rem_pct:.0f}%</span>
                                <span>Risvegli: {awake_pct:.0f}%</span>
                            </div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
            
            # 4. METRICHE DETTAGLIATE PER GIORNO - IN TABELLA
            with st.expander("üìÖ Metriche Dettagliate per Giorno", expanded=True):
                if not daily_metrics:
                    st.info("Non ci sono abbastanza dati per un'analisi giornaliera")
                else:
                    # Prepara i dati per la tabella
                    table_data = []
                    
                    for day_date, day_metrics in daily_metrics.items():
                        day_dt = datetime.fromisoformat(day_date)
                        row = {
                            'Data': day_dt.strftime('%d/%m/%Y'),
                            'Battito (bpm)': f"{day_metrics.get('hr_mean', 0):.1f}",
                            'SDNN (ms)': f"{day_metrics.get('sdnn', 0):.1f}",
                            'RMSSD (ms)': f"{day_metrics.get('rmssd', 0):.1f}",
                            'Coerenza (%)': f"{day_metrics.get('coherence', 0):.1f}",
                            'Potenza Totale': f"{day_metrics.get('total_power', 0):.0f}",
                            'LF': f"{day_metrics.get('lf', 0):.0f}",
                            'HF': f"{day_metrics.get('hf', 0):.0f}",
                            'LF/HF': f"{day_metrics.get('lf_hf_ratio', 0):.2f}",
                            'Sonno Totale (h)': f"{day_metrics.get('sleep_duration', 0):.1f}",
                            'Efficienza (%)': f"{day_metrics.get('sleep_efficiency', 0):.1f}",
                            'HR Riposo': f"{day_metrics.get('sleep_hr', 0):.1f}",
                            'Sonno Leggero (h)': f"{day_metrics.get('sleep_light', day_metrics.get('sleep_duration', 0) * 0.5):.1f}",
                            'Sonno Profondo (h)': f"{day_metrics.get('sleep_deep', day_metrics.get('sleep_duration', 0) * 0.2):.1f}",
                            'Sonno REM (h)': f"{day_metrics.get('sleep_rem', day_metrics.get('sleep_duration', 0) * 0.2):.1f}",
                            'Risvegli (h)': f"{day_metrics.get('sleep_awake', day_metrics.get('sleep_duration', 0) * 0.1):.1f}"
                        }
                        table_data.append(row)
                    
                    # Converti in DataFrame
                    df = pd.DataFrame(table_data)
                    
                    # Styling della tabella
                    st.markdown("""
                    <style>
                    .metric-table {
                        font-size: 14px;
                    }
                    .metric-table thead th {
                        background-color: #3498db;
                        color: white;
                        font-weight: bold;
                    }
                    </style>
                    """, unsafe_allow_html=True)
                    
                    # Mostra la tabella
                    st.dataframe(
                        df,
                        use_container_width=True,
                        hide_index=True,
                        height=min(400, 50 + len(df) * 35)  # Altezza dinamica
                    )
                    
                    # Download della tabella
                    csv = df.to_csv(index=False, sep=';')
                    st.download_button(
                        label="üì• Scarica Tabella come CSV",
                        data=csv,
                        file_name=f"hrv_analisi_giornaliera_{datetime.now().strftime('%Y%m%d')}.csv",
                        mime="text/csv",
                        use_container_width=True
                    )
                    
                    # Grafico dettagliato con zoom interattivo
                    st.subheader("üìà Andamento Dettagliato HRV")
                    
                    # Crea timeline dettagliata dai dati RR
                    if len(rr_intervals) > 0:
                        # Calcola i timestamp per ogni battito
                        timestamps = []
                        current_time = start_time
                        
                        for rr in rr_intervals:
                            timestamps.append(current_time)
                            current_time += timedelta(milliseconds=rr)
                        
                        # Calcola HRV in finestre mobili (per SDNN e RMSSD)
                        window_size = min(300, len(rr_intervals) // 10)  # Finestra adattiva
                        if window_size < 30:
                            window_size = min(30, len(rr_intervals))
                        
                        hr_instant = [60000 / rr for rr in rr_intervals]
                        sdnn_moving = []
                        rmssd_moving = []
                        moving_timestamps = []
                        
                        for i in range(len(rr_intervals) - window_size):
                            window_rr = rr_intervals[i:i + window_size]
                            window_hr = hr_instant[i:i + window_size]
                            
                            # Calcola SDNN e RMSSD per la finestra
                            sdnn = np.std(window_rr, ddof=1) if len(window_rr) > 1 else 0
                            differences = np.diff(window_rr)
                            rmssd = np.sqrt(np.mean(np.square(differences))) if len(differences) > 0 else 0
                            
                            sdnn_moving.append(sdnn)
                            rmssd_moving.append(rmssd)
                            moving_timestamps.append(timestamps[i + window_size // 2])
                        
                        # Crea il grafico principale con zoom interattivo
                        fig_main = go.Figure()
                        
                        # Aggiungi HR istantaneo (smooth)
                        fig_main.add_trace(go.Scatter(
                            x=timestamps,
                            y=hr_instant,
                            mode='lines',
                            name='Battito Istantaneo',
                            line=dict(color='#e74c3c', width=1),
                            opacity=0.7
                        ))
                        
                        # Aggiungi SDNN mobile
                        if sdnn_moving:
                            fig_main.add_trace(go.Scatter(
                                x=moving_timestamps,
                                y=sdnn_moving,
                                mode='lines',
                                name='SDNN Mobile',
                                line=dict(color='#3498db', width=2),
                                yaxis='y2'
                            ))
                        
                        # Aggiungi RMSSD mobile
                        if rmssd_moving:
                            fig_main.add_trace(go.Scatter(
                                x=moving_timestamps,
                                y=rmssd_moving,
                                mode='lines',
                                name='RMSSD Mobile',
                                line=dict(color='#2ecc71', width=2),
                                yaxis='y3'
                            ))
                        
                        # Layout del grafico principale con zoom
                        fig_main.update_layout(
                            title='Andamento Dettagliato HRV - Zoomma con mouse/touch',
                            xaxis=dict(
                                title='Tempo',
                                rangeslider=dict(visible=False)  # Nascondi il rangeslider
                            ),
                            yaxis=dict(
                                title=dict(text='Battito (bpm)', font=dict(color='#e74c3c')),
                                tickfont=dict(color='#e74c3c')
                            ),
                            yaxis2=dict(
                                title=dict(text='SDNN (ms)', font=dict(color='#3498db')),
                                tickfont=dict(color='#3498db'),
                                overlaying='y',
                                side='right',
                                position=0.85
                            ),
                            yaxis3=dict(
                                title=dict(text='RMSSD (ms)', font=dict(color='#2ecc71')),
                                tickfont=dict(color='#2ecc71'),
                                overlaying='y',
                                side='right',
                                position=0.15
                            ),
                            height=500,
                            showlegend=True,
                            hovermode='x unified'
                        )
                        
                        # Aggiungi bottoni per lo zoom
                        fig_main.update_layout(
                            xaxis=dict(
                                rangeselector=dict(
                                    buttons=list([
                                        dict(count=1, label="1h", step="hour", stepmode="backward"),
                                        dict(count=6, label="6h", step="hour", stepmode="backward"),
                                        dict(count=1, label="1gg", step="day", stepmode="backward"),
                                        dict(step="all", label="Tutto")
                                    ])
                                ),
                                rangeslider=dict(visible=False),
                                type="date"
                            )
                        )
                        
                        st.plotly_chart(fig_main, use_container_width=True)
                        
                        # Istruzioni per l'uso
                        st.caption("""
                        **üîç Come zoommare:**
                        - **Mouse:** Trascina per selezionare un'area da zoommare
                        - **Doppio click:** Reset dello zoom
                        - **Pulsanti sopra:** Zoom predefiniti (1h, 6h, 1 giorno, Tutto)
                        """)
                        
                        # Informazioni sui dati
                        st.info(f"""
                        **üìä Informazioni Dati:**
                        - **Battiti totali:** {len(rr_intervals)}
                        - **Durata registrazione:** {timeline['total_duration_hours']:.1f} ore
                        - **Finestra mobile:** {window_size} battiti
                        - **Battito medio:** {np.mean(hr_instant):.1f} bpm
                        - **SDNN medio:** {np.mean(sdnn_moving) if sdnn_moving else 0:.1f} ms
                        - **RMSSD medio:** {np.mean(rmssd_moving) if rmssd_moving else 0:.1f} ms
                        """)
                    
                    else:
                        st.warning("Dati insufficienti per l'analisi dettagliata")
                    
                    # Statistiche generali (non pi√π del periodo selezionato)
                    st.subheader("üìä Statistiche Generali")
                    
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("Battito Medio", f"{np.mean(hr_instant):.1f} bpm")
                    with col2:
                        st.metric("SDNN Medio", f"{np.mean(sdnn_moving) if sdnn_moving else 0:.1f} ms")
                    with col3:
                        st.metric("RMSSD Medio", f"{np.mean(rmssd_moving) if rmssd_moving else 0:.1f} ms")
                    with col4:
                        st.metric("Battiti Totali", len(rr_intervals))
            
            # 5. SALVATAGGIO ANALISI
            if st.button("üíæ Salva Analisi nel Database", type="primary"):
                user_key = get_user_key(user_profile)
                if user_key and user_key in st.session_state.user_database:
                    analysis_data = {
                        'timestamp': datetime.now().isoformat(),
                        'recording_start': timeline['start_time'].isoformat(),
                        'recording_end': timeline['end_time'].isoformat(),
                        'recording_duration_hours': timeline['total_duration_hours'],
                        'rr_intervals_count': len(rr_intervals),
                        'overall_metrics': avg_metrics,
                        'daily_metrics': daily_metrics
                    }
                    st.session_state.user_database[user_key]['analyses'].append(analysis_data)
                    save_user_database()
                    st.success("‚úÖ Analisi salvata nel database!")
                else:
                    st.error("‚ùå Salva prima il profilo utente!")
            # üîºüîºüîº FINE NUOVA ANALISI üîºüîºüîº
            
        except Exception as e:
            st.error(f"‚ùå Errore durante l'elaborazione del file: {str(e)}")
    
    else:
        # Schermata iniziale
        st.info("""
        ### üëÜ Carica un file IBI per iniziare l'analisi
        
        **Formati supportati:** .txt, .csv, .sdf
        
        Il file deve contenere gli intervalli IBI (Inter-Beat Intervals) in millisecondi, uno per riga.
        
        ### üéØ FUNZIONALIT√Ä COMPLETE:
        - ‚úÖ **Calcoli HRV realistici** con valori fisiologici corretti
        - ‚úÖ **Analisi giornaliera** per registrazioni lunghe
        - ‚úÖ **Tracciamento attivit√†** completo con modifica/eliminazione
        - ‚úÖ **Analisi alimentazione** con database nutrizionale ESPANSO
        - ‚úÖ **Persistenza dati** - utenti salvati automaticamente
        """)

if __name__ == "__main__":
    main()